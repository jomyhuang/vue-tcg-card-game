<template>
<div class="gameapp">
  <Row class="gameboard">
    <div>
      <h2>{{ msg }} : Turn#{{ this.turnCount }} $ {{ $store.state.storemsg }}</h2>
      <Button @click="gameTest()">GAME TEST</Button>
      <Button @click="battleshow(0)">Battle Show</Button>
    </div>
  </Row>
  <Row class="gameboard">
    <Col span="4">
    <div class="gameboard">
      <h3>deck2</h3>
      <comDeck :player="$store.state.player2"></comDeck>
    </div>
    </Col>
    <Col span="20">
    <div class="gameboard" style="min-height:200px">
      <comHand :player="$store.state.player2"></comHand>
    </div>
    <div class="gameboard" style="min-height:200px">
      <comZone :player="$store.state.player2"></comZone>
    </div>
    </Col>
  </Row>
  <Row class="gameboard">
    <Col span="20">
    <div class="gameboard" style="min-height:200px">
      <comZone :player="$store.state.player1"></comZone>
    </div>
    <div class="gameboard" style="min-height:200px">
      <comHand :player="$store.state.player1"></comHand>
    </div>
    </Col>
    <Col span="4">
    <div class="gameboard">
      <h3>deck1</h3>
      <comDeck :player="$store.state.player1"></comDeck>
      <Button @click="$store.dispatch('DRAW',1)">DRAW</Button>
      <Button @click="playcard()">PLAY</Button>
    </div>
    </Col>
  </Row>
  <Row class="gameboard">
    <div>
      <h2>{{ msg }} : Turn#{{ this.turnCount }} $ {{ $store.state.storemsg }}</h2>
      <!-- <Button @click="gameloop_temp()">TEST LOOP</Button> -->
      <Button @click="gameloop()" shape="circle">GAME LOOP</Button>
      <Button @click="gameloop(true)" shape="circle">GAME LOOP UI</Button>
      <Button @click="battleshow(0)" shape="circle">Battle Show</Button>
      <Button @click="run_gameloop()">QUICK RUN</Button>
      <Button @click="run_gameloop(1)">QUICK RUN ONE TURN</Button>
      <Button @click="gameTestBattle()">BATTLE TEST CARD</Button>
      <BR/>
      显示讯息 <i-switch v-model="isMessage"/>
      <Button @click="gameTest()">TEST</Button>
      <Button @click="gameReset()">RESET</Button>
      <Button @click="gameNewdeck()">NewDeck</Button>
      <Button @click="gameNewdeck(true)">NewDeck UI</Button>
      <Button @click="scoreshow()" shape="circle">Score Show</Button>
    </div>
  </Row>
  <comMessage ref="info"></comMessage>
  <comBattle ref="battle" v-model="$store.state.battle"></comBattle>
  <comScore ref="score" v-model="$store.state.score"></comScore>
</div>
</template>

<script>
import comDeck from './comDeck.vue'
import comHand from './comHand.vue'
import comZone from './comZone.vue'
import comBattle from './comBattle.vue'
import comScore from './comScore.vue'
import comMessage from './comMessage.vue'

import testdeck1 from '@/components/decktest1.js'
import testdeck2 from '@/components/decktest2.js'

import mutil from '@/mutil'
import R from 'ramda'



export default {
  name: 'GameApp',
  data() {
    return {
      msg: 'SDW GAME APP',
      initial: false,
      isMessage: true,
      isTestmode: false,
    }
  },
  components: {
    comDeck,
    comHand,
    comZone,
    comBattle,
    comMessage,
    comScore,
  },
  created() {},
  mounted() {
    console.log('gameapp.vue mounted');
    // console.log('gameapp.vue mixinEffect effect');
    // mutil.mixinEffect()
    console.log('gameapp.vue GAME initial')
    this.$store.dispatch('GAME_INIT_STORE',
      { store: this.$store,
        mainapp: this,
      })
    mutil.setUI(this.battleshow)
    // mutil.tapUI()

    this.$store.dispatch('GAME_READY')
  },
  beforeDestroy() {},
  computed: {
    currentPlayer: function() {
      return this.$store.state.currentPlayer
    },
    firstPlayer: function() {
      return this.$store.state.firstPlayer
    },
    opponentPlayer: function() {
      return this.$store.state.opponentPlayer
    },
    turnCount: function() {
      return this.$store.state.game.turnCount
    },
    score: function() {
      return this.$store.state.game.score
    },
    gameover: function() {
      return this.$store.state.game.over
    },
    config: function() {
      return this.$store.state.game.config
    },
  },
  methods: {
    testui() {
      console.log('TEST UI');
    },
    gameTestmode() {
      this.isTestmode = true
      console.log('TURN ON TEST MODE')
    },
    gameNewdeck(umi = false) {
      this.gameReset({
        decklist: [testdeck1, testdeck2],
        shuffle: false,
      })
      if (umi) {
        this.run_command('GAME_SET_AGENT', {
          player: this.$store.state.player1,
          agent: null
        })
      }
      this.UImessage('game set new deck')
    },
    gameTestBattle() {
      this.gameReset()
      this.gameNewdeck()

      this.run_battle({
        BATTLE_DECALRE_ATTACKER: mutil.makecard('JW15-001', this.$store.state.player1, true),
        BATTLE_PLAY_SUPPORTER: mutil.makecard('JW15-001', this.$store.state.player1),
        BATTLE_OPP_DECLARE_DEFENSER: mutil.makecard('JW15-002', this.$store.state.player2, true),
        BATTLE_OPP_PLAY_SUPPORTER: mutil.makecard('JW15-002', this.$store.state.player2),
      })
    },
    gameReset(init) {
      // this.$Message.info({
      //           content: 'Game Reset',
      //           duration: 2,
      //       })
      console.log('game reset');
      this.$store.dispatch('GAME_RESET')
      console.log(init);
      this.$store.dispatch('GAME_READY', init)
      this.UImessage('game Reset')

    },
    gameStart() {
      // console.log('game Start')
      // this.$store.commit('SELECT_PLAYER', this.$store.state.player2)
      // this.$store.dispatch('DRAW', 5)
      // this.$store.dispatch('DRAW_TO_ZONE', 5)
      //
      // this.$store.commit('SELECT_PLAYER', this.$store.state.player1)
      // this.$store.dispatch('DRAW', 5)
      // this.$store.dispatch('DRAW_TO_ZONE', 5)
    },
    battleshow(value = 1000, onclose) {
      return this.$refs.battle.open(value,onclose)
    },
    scoreshow(value=0,onclose) {
      return this.$refs.score.open(value,onclose)
    },
    playcard() {
      // this.$store.dispatch( 'SELECT_PLAYER', this.$store.state.player1 )
      // this.$store.dispatch( 'SELECT_CARDLIST', this.$store.state.currentPlayer.hand )
      // this.$store.dispatch( 'ACT_SELECT_CARD_START', { list: 'hand', action: 'test_action' } )
      this.$store.dispatch('ACT_SELECT_CARD_START', {
        list: 'hand',
        many: 1,
        selectedMuation: (state, card) => {
          state.storemsg = `call back select ${card.name}`
          card.name = card.name + '**'
          console.log(`callback test check ${card.name} / ${state.storemsg}`)
        },
        selectedAction: (state, card) => {
          this.$store.commit('PICK_CARD', card)
          this.$store.commit('TO_BASE')
        },
        thenAction: (state) => {
          console.log('this is then action end of selection')
        },
      })
      // } ).then( () => {
      //   console.log('hello promise')
      // })
    },
    UImessage(msg) {
      this.msg = msg
      this.run_command('STORE_MESSAGE', msg)
      console.info('%c' + msg, 'color:green')

      if(this.isTestmode) return
      this.$Message.info({
                content: msg,
                duration: 1.5,
            })
    },
    message(msg) {
      // return promise from component
      // return this.$refs.info.async_message(msg)
      this.msg = msg
      const duration = 500
      this.run_command('STORE_MESSAGE', msg)
      console.info('%c' + msg, 'color:green')
      // if(this.config.message) {
      //   return new Promise((resolve, reject) => {
      //       const res = this.$Message.info({ content: this.msg, duration: 2000 })
      //       resolve()
      //   })
      // }
      // return true
      if(this.isTestmode) return

      if (this.config.message) {
        return new Promise((resolve, reject) => {
          this.$Notice.open({
            title: msg,
            duration: 1,
            onClose: () => resolve()
          })
          resolve()
        })
      }
      return true
      // return this.config.message ? this.$Notice.open({title: msg, duration: 2.5}) : true
      // return this.config.message ? this.$refs.info.async_message(msg,duration) : true
    },
    run_message(msg) {
      return this.message(msg)
    },
    run_next(newphase, payload) {
      console.log(`next %c${newphase}`, 'color:blue')
      // dispatch('GAME_PHASE',newphase)
      return this.$store.dispatch(newphase, payload)
    },
    run_command(type, payload) {
      if (this.$store._actions[type]) {
        return this.$store.dispatch(type, payload)
      } else {
        return this.$store.commit(type, payload)
      }
    },
    async_battleshow(value = 1000) {
      if (!this.config.battelshow) return
      if(this.isTestmode) return

      // TIPS: 取消使用loop check，使用传入 resolve -> watch -> callback resolve()
      return new Promise((resolve, reject) => {
        this.battleshow(value, resolve)
      })

      // if (value == 0) {
      //   // return this.__waiting_check(() => !this.$refs.battle.battleVisible)
      //   return new Promise((resolve, reject) => {
      //     // test callback resolve
      //     this.battleshow(value,resolve)
      //   })
      // } else {
      //   return new Promise((resolve, reject) => {
      //     this.battleshow(value)
      //     setTimeout(()=>resolve(),value+500)
      //   })
      // }
    },
    __waiting_check(checkfunc = () => true) {
      return new Promise(async function(resolve, reject) {
        let waiting = true
        while (waiting) {
          await new Promise(function(resolve, reject) {
            setTimeout(function() {
              resolve()
            }, 1000)
          })
          if (checkfunc()) {
            waiting = false
          }
        }
        resolve()
      })
    },
    // async __waiting_check(checkfunc = () => true) {
    //   let waiting = true
    //   while (waiting) {
    //     await new Promise(function(resolve, reject) {
    //       setTimeout(function() {
    //         resolve()
    //       }, 1000)
    //     })
    //     if (checkfunc()) {
    //       // console.log('waiting_click pass, exit loop');
    //       waiting = false
    //     }
    //   }
    // },
    async gameloop(umi = false) {
      console.log('start gameloop')

      if (this.$store.state.game.started) {
        return await this.message('对战已经开始')
      }

      if (umi) {
        this.run_command('GAME_SET_AGENT', {
          player: this.$store.state.player1,
          agent: null
        })
      }
      this.run_command('GAME_SET_CONFIG', {
        message: this.isMessage,
        battelshow: true,
      })

      let firstplayer = null
      await this.run_next('GAME_START')
      await this.message('游戏开始', 2000)
      await this.run_next('GAME_WHO_FIRST').then((who) => {
        firstplayer = who
      })
      await this.run_next('GAME_SET_FIRSTPLAYER', firstplayer)
      await this.message(`${this.firstPlayer.name} 先攻`)

      let loop = true
      do {

        await this.run_next('GAME_TURN_BEGIN')
        await this.message(`${this.currentPlayer.name} 我的回合！！ 第${this.$store.state.game.turnCount}回合`)
        await this.message('抽牌')
        await this.run_next('GAME_DRAW')
        await this.message('战斗开始')
        await this.run_next('BATTLE_START')

        await this.message(`${this.currentPlayer.name} 宣告攻击精灵`)
        await this.run_next('BATTLE_DECALRE_ATTACKER')
        await this.async_battleshow(1000)

        await this.message(`指定攻击目标`)
        await this.run_next('BATTLE_OPP_DECLARE_DEFENSER')
        await this.async_battleshow(1000)

        await this.message(`${this.currentPlayer.name} 派遣支援精灵`)
        await this.run_next('BATTLE_PLAY_SUPPORTER')

        await this.message(`${this.opponentPlayer.name} 派遣支援精灵`)
        await this.run_next('BATTLE_OPP_PLAY_SUPPORTER')

        await this.async_battleshow(0)

        await this.message(`效果：发动阶段`)
        await this.run_next('BATTLE_EFFECT')
        await this.message(`效果：清除阶段`)
        await this.run_next('BATTLE_EFFECT_CLEAR')

        await this.run_next('BATTLE_END')

        // check game over block
        await this.run_next('GAME_CHECK_GAMEOVER').catch((reason) => {
          console.log(`GAMEOVER: ${reason}`)
        })
        if (this.gameover) break
        // end check game over

        await this.run_next('GAME_NEXT_TURN')

        if (this.turnCount >= this.config.maxturn)
          loop = false

      } while (!this.gameover && loop)

      if (!loop)
        console.log(`end of gameloop, turn ${this.turnCount}`)

      if (this.gameover) {
        console.log(`game over, turn ${this.turnCount}`)
        await this.message(`游戏结束`)

        if (this.score.draw) {
          console.log(`game draw is true`)
          await this.message(`战斗平手`)
        } else {
          console.log(`game win ${this.score.win.id} ${this.score.win.name}`)
          console.log(`game lose ${this.score.lose.id} ${this.score.lose.name}`)
          await this.message(`获胜 ${this.score.win.id} ${this.score.win.name}`)
        }
        await this.scoreshow(0)
      }
    },
    // 单回合战斗测试
    async run_battle(testbattle) {
      await this.run_message('run_battle START battle')
      await this.run_message('set test data')
      await this.run_command('TEST_SET', testbattle)

      await this.run_next('GAME_START')
      let firstplayer = this.$store.state.player1
      await this.run_next('GAME_SET_FIRSTPLAYER', firstplayer)

      await this.run_next('GAME_TURN_BEGIN')
      await this.run_next('BATTLE_START')

      await this.run_next('BATTLE_DECALRE_ATTACKER')
      await this.run_next('BATTLE_OPP_DECLARE_DEFENSER')
      await this.run_next('BATTLE_PLAY_SUPPORTER')
      await this.run_next('BATTLE_OPP_PLAY_SUPPORTER')

      await this.run_next('BATTLE_EFFECT')
      // pass BATTLE_EFFECT_CLEAR
      // await this.run_next('BATTLE_EFFECT_CLEAR')
      await this.run_next('BATTLE_END')
      await this.run_message('run_battle END battle')
    },
    // run gameloop + step 非同步版本／回合step步进版本
    async run_gameloop(testturn = 0) {
      this.run_message('start run gameloop test')

      if(R.isNil(this.$store.state.player1.agent)) {
        this.run_message('run_gameloop 无法使用UI agent')
        return
      }

      if (this.$store.state.game.started) {
        this.run_message('对战已经开始')
        return
      }

      let firstplayer = null
      this.run_next('GAME_START')
      this.run_message('游戏开始')

      this.run_next('GAME_WHO_FIRST')
      firstplayer = this.$store.state.player1
      this.run_next('GAME_SET_FIRSTPLAYER', firstplayer)
      this.run_message(`${this.firstPlayer.name} 先攻`)

      let maxturn = testturn > 0 ? testturn : this.config.maxturn
      // maxturn = 1
      let loop = true
      do {

        await this.run_step()

        loop = await this.run_step_nextturn()
        if (this.gameover)
          break

        if (this.turnCount >= maxturn)
          loop = false

      } while (!this.gameover && loop)

      if (!loop)
        console.log(`end of gameloop, turn ${this.turnCount}`)

      if (this.gameover) {
        this.run_message(`GAMEOVER: ${this.score.reason}`)
        this.run_message(`game over, turn ${this.turnCount}`)
        if (this.score.draw) {
          this.run_message(`game draw is true`)
        } else {
          this.run_message(`game win ${this.score.win.id} ${this.score.win.name}`)
          this.run_message(`game lose ${this.score.lose.id} ${this.score.lose.name}`)
        }
        await this.scoreshow(0)
      }
    },
    async run_step() {

      this.run_next('GAME_TURN_BEGIN')
      this.run_message(`${this.currentPlayer.name} 我的回合！！ 第${this.$store.state.game.turnCount}回合`)
      this.run_message('抽牌')
      this.run_next('GAME_DRAW')

      this.run_message('战斗开始')
      this.run_next('BATTLE_START')

      this.run_message(`${this.currentPlayer.name} 宣告攻击精灵`)
      this.run_next('BATTLE_DECALRE_ATTACKER')

      this.run_message(`指定攻击目标`)
      this.run_next('BATTLE_OPP_DECLARE_DEFENSER')

      this.run_message(`${this.currentPlayer.name} 派遣支援精灵`)
      this.run_next('BATTLE_PLAY_SUPPORTER')

      this.run_message(`${this.opponentPlayer.name} 派遣支援精灵`)
      this.run_next('BATTLE_OPP_PLAY_SUPPORTER')

      this.run_message(`效果：发动阶段`)
      await this.run_next('BATTLE_EFFECT')
      this.run_message(`效果：清除阶段`)
      await this.run_next('BATTLE_EFFECT_CLEAR')

      await this.run_next('BATTLE_END')

    },
    run_step_nextturn() {
      let result = true

      this.run_next('GAME_CHECK_GAMEOVER').catch((reason) => {
        // this.run_message(`GAMEOVER: ${reason}`)
        result = false
      })
      if (!this.gameover)
        this.run_next('GAME_NEXT_TURN')

      return result
    },
    gameTest() {
      // this.$store.commit('GAME_SET_CURRENTPLAYER', this.$store.state.player1)
      // this.$store.commit('GAME_NEXT_PLAYER')
      // this.$store.commit('GAME_NEXT_PLAYER')
      // this.$refs.info.message('讯息测试～')
      console.log('gameTest call')

      this.$store.dispatch('M2', {
        name: 'test name',
        age: 10
      })
      // this.asyncRun()
    },
    // end of methods
  }
}
</script>

<style>
@import '../style/base.scss';
</style>

<!-- Add "scoped" attribute to limit CSS to this component only -->
<style scoped>
/* scoped 不含向下传递 */

h2 {
  color: blue;
}


/*
h1,
h2 {
  font-weight: bold;
}*/


/*.gameboard {
  border: thin solid #0000ff;
  background-color: lightblue;
  padding: 15px;
}

.flex-container {
  display: -webkit-flex;
  display: flex;
  -webkit-flex-wrap: wrap;
  flex-wrap: wrap;
}

.flex-item {
  background-color: lightgrey;
  width: 150px;
  height: 200px;
  margin: 10px;
  border: none 5px #000000;
  -moz-border-radius: 5px;
  -webkit-border-radius: 5px;
  border-radius: 5px;
}*/
</style>
